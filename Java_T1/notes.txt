### T01 Basis

**ToString**

Die Methode `toString()` wird verwendet, um Objekte als Zeichenkette darzustellen. Standardmäßig gibt sie nur den Klassennamen und die Speicheradresse zurück. Wenn du die Methode überschreibst, kannst du eine benutzerdefinierte Darstellung des Objekts liefern.

**Beispiel:**
```java
@Override
public String toString() {
    return "Bruch: " + zaehler + "/" + nenner;
}
```

**Bruchzahlen als Objekte**

Brüche können in Java als Objekte durch die Klasse `BruchZahl` dargestellt werden. Ein Bruch hat einen Zähler und einen Nenner. Du kannst dann mit diesen Objekten mathematische Operationen wie Addition, Subtraktion, Multiplikation und Division durchführen.

**Beispiel:**
```java
public class BruchZahl {
    private int zaehler;
    private int nenner;

    public BruchZahl(int zaehler, int nenner) {
        if (nenner == 0) throw new ArithmeticException("Nenner darf nicht null sein!");
        this.zaehler = zaehler;
        this.nenner = nenner;
    }

    public BruchZahl addiere(BruchZahl anderer) {
        int neuerZaehler = this.zaehler * anderer.nenner + anderer.zaehler * this.nenner;
        int neuerNenner = this.nenner * anderer.nenner;
        return new BruchZahl(neuerZaehler, neuerNenner);
    }
}
```

---

### T02 Kunde

**Toolbox**

Eine Toolbox ist eine Sammlung von wiederverwendbaren Hilfsmethoden. Sie ist modular und hilft bei Aufgaben wie mathematischen Berechnungen oder Formatierungen.

**Beispiel für eine einfache Toolbox:**
```java
public class Toolbox {
    public static int addiere(int a, int b) {
        return a + b;
    }
}
```

**`==` und `equals()`**

- `==` vergleicht, ob zwei Referenzen auf dasselbe Objekt zeigen.
- `equals()` vergleicht, ob der Inhalt von zwei Objekten gleich ist.

**Beispiel für `equals()`-Methode:**
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Person person = (Person) obj;
    return name.equals(person.name);
}
```

**toString für `int` zu `String`**

Um eine `int`-Zahl in einen String umzuwandeln, kannst du `Integer.toString()` verwenden.

**Beispiel:**
```java
int zahl = 123;
String str = Integer.toString(zahl);  // Wandelt die Zahl 123 in den String "123" um
```

---

### T03 Brüche als Objekte

**Brüche als Objekte**

Ein Bruch wird in Java durch die Klasse `BruchZahl` als Objekt dargestellt, das Zähler und Nenner enthält. Mit Methoden wie `addiere()` kannst du mathematische Operationen durchführen.

**Beispiel für Addition:**
```java
BruchZahl bruch1 = new BruchZahl(1, 2);   // 1/2
BruchZahl bruch2 = new BruchZahl(1, 3);   // 1/3
BruchZahl ergebnis = bruch1.addiere(bruch2); // Ergebnis: 5/6
```

### Immutable Klasse Konzept

**Konstruktor**

Der Konstruktor stellt sicher, dass der Nenner nie null ist, da eine Division durch null nicht erlaubt ist. Wenn der Nenner null ist, wird eine `ArithmeticException` geworfen.

**Beispiel für den Konstruktor:**
```java
public BruchZahl(int zaehler, int nenner) {
    if (nenner == 0) throw new ArithmeticException("Nenner darf nicht null sein!");
    this.zaehler = zaehler;
    this.nenner = nenner;
}
```

**Mathematische Operationen**

Methoden wie `addiere()`, `subtrahiere()`, `multipliziere()` und `dividiere()` berechnen den neuen Zähler und Nenner.

**Beispiel für Division:**
```java
public BruchZahl dividiere(BruchZahl anderer) {
    if (anderer.zaehler == 0) throw new ArithmeticException("Division durch null!");
    int neuerZaehler = this.zaehler * anderer.nenner;
    int neuerNenner = this.nenner * anderer.zaehler;
    return new BruchZahl(neuerZaehler, neuerNenner);
}
```

**Kürzen eines Bruchs**

Ein Bruch wird durch den größten gemeinsamen Teiler (ggT) gekürzt.

**Beispiel für das Kürzen:**
```java
public BruchZahl kuerze() {
    int ggT = berechneGGt(this.zaehler, this.nenner);
    this.zaehler /= ggT;
    this.nenner /= ggT;
    return this;
}
```

**Fehlerbehandlung**

Bei einer Division durch null wird eine `ArithmeticException` geworfen.

---

### T04 Kapselung und Wiederholung

**Klasse**

Eine Klasse ist eine Vorlage für Objekte. Sie definiert die Daten (Felder) und das Verhalten (Methoden) der Objekte.

**Beispiel für eine Klasse:**
```java
public class Person {
    private String name;
    private int alter;

    public Person(String name, int alter) {
        this.name = name;
        this.alter = alter;
    }
}
```

**Kapselung**

Kapselung schützt die Daten eines Objekts vor unbefugtem Zugriff. Mit Getter- und Setter-Methoden kannst du auf die Felder zugreifen oder sie ändern.

**Beispiel für Getter und Setter:**
```java
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}
```

**Fortgeschrittene Kapselung**

Es gibt auch spezielle Initialisierer, die bei der Objektinitialisierung helfen, sowie innere Klassen, die auf Felder und Methoden der äußeren Klasse zugreifen können.

---

### HashSet vs. TreeSet

- **HashSet:** Schneller beim Suchen und Hinzufügen von Elementen (O(1)), jedoch ohne garantierte Reihenfolge.
- **TreeSet:** Sortiert die Elemente, ist aber langsamer bei der Suche und beim Hinzufügen (O(log n)).

**Beispiel für ein HashSet:**
```java
Set<String> set = new HashSet<>();
set.add("Apfel");
set.add("Banane");
set.add("Kirsche");
```

---

### ArrayList vs. LinkedList

- **ArrayList:** Bietet schnellen Zugriff auf Elemente (O(1)), aber langsames Einfügen und Löschen (O(n)).
- **LinkedList:** Bietet schnelles Einfügen und Löschen (O(1)), aber langsamen Zugriff auf Elemente über den Index (O(n)).

---

### Java Sortierung mit `Comparator`

Ein `Comparator` ermöglicht es dir, die Reihenfolge von Objekten nach einer bestimmten Regel festzulegen.

**Beispiel für einen `Comparator`:**
```java
@Override
public int compareTo(Person o) {
    Collator collator = Collator.getInstance(Locale.GERMANY);
    return collator.compare(this.name, o.name);
}
```

### Default Konstruktor

Ein Default-Konstruktor ist ein Konstruktor ohne Parameter, der automatisch von der Klasse bereitgestellt wird, wenn kein anderer Konstruktor definiert ist. Er wird verwendet, um ein Objekt mit Standardwerten zu initialisieren.

**Beispiel für einen Default-Konstruktor:**
```java
public class Auto {
    private String marke;
    private int baujahr;

    // Default Konstruktor
    public Auto() {
        this.marke = "Unbekannt";
        this.baujahr = 2000;
    }

    public static void main(String[] args) {
        Auto meinAuto = new Auto();
        System.out.println(meinAuto.marke); // Ausgabe: Unbekannt
        System.out.println(meinAuto.baujahr); // Ausgabe: 2000
    }
}
```


### Basisklasse 

- es gibt viele klassen in java die final sind




## JFRAME Klasse ist eine möglichkeit ein Java fenster zu erstellen

// Swing - billig schnell cool
// JavaFX - hat sich nicht durchgesetzt


import javax.swing.JFrame;
public class TestMeinFenster {
	public static void main(String[] args) {
		MeinFenster fenster = new MeinFenster();
		fenster.setSize(500, 500 );
		fenster.setVisible(true);
		fenster.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}

Visueles programmieren ist möglich - hierzu gibz es möglichkeit mit JFrame eine hilfe zu herbeirufen und hier die fenster zu definieren.

Static Variablen wereb nicht serialisiert.




### T05 Vererbung II - Serielisierung

1. List
    Geordnet: Elemente in Reihenfolge.
    Duplikate: Erlaubt.
    Zugriff: Über Index (z.B. get(0)).

2. Set
    Ungeordnet: Keine feste Reihenfolge.
    Duplikate: Nicht erlaubt.
    Verwendung: Wenn du nur einzigartige Elemente speichern möchtest.

3. Map
    Schlüssel-Wert-Paare: Jeder Schlüssel ist einzigartig.
    Zugriff: Über Schlüssel (z.B. map.get(key)).
    Duplikate: Erlaubt bei den Werten, aber nicht bei den Schlüsseln.



Serialisierung in Java
    Definition: Umwandlung eines Objekts in eine Byte-Darstellung zur Speicherung oder Übertragung.
    Ziel: Objekte in Dateien oder über Netzwerke speichern.
    Benötigte Schnittstelle: Serializable-Interface.
    Vorteil: Ermöglicht Persistenz und Kommunikation zwischen verschiedenen Systemen.



Hierzu haben wir eine universelle Toolbox verwendet, um serialisierbare Objekte zu speichern und zu laden. 
Um mit null-Werten umzugehen, gibt es zwei Ansätze: 
Der erste ist die Verwendung von Optional, der zweite ist, eine eigene Klasse zu schreiben, die NullPointerExceptions vermeidet.

Optional        - ist die empfohlene Java-Klasse zur Handhabung von null-Werten, da sie eine explizite Kontrolle und Fehlervermeidung ermöglicht.
Eigene Klasse   - wäre aufwendiger, aber könnte genutzt werden, um NullPointerExceptions manuell zu vermeiden. 



Bei der Deep Copy in Java geht es um Serialisierung: 
Man serialisiert das Objekt (erstellt eine Byte-Kopie) und deserialisiert es anschließend, um eine neue, unabhängige Kopie des Objekts zu erstellen.

Ressourcenmanagement bedeutet, dass Dateien, Streams oder Verbindungen korrekt geöffnet und geschlossen werden.
Verwende close() und dispose() anstelle von finalize(), da diese Methoden sofort aufgerufen werden.

close():       Schließt Ressourcen wie Streams oder Datenbanken. 
Beispiel:      try (FileInputStream fis = new FileInputStream("file.txt")) { }

dispose():     Gibt GUI-Komponenten (z.B. Fenster) in Swing/AWT frei.
Beispiel:      frame.dispose();




Es kann aber auch der compiler für den Programmierer übernehmen.
finally block muss aber immer gemacht werden.


Bei Swing wird die Methode dispose() aufgerufen, wenn ein Fenster (z.B. JFrame) geschlossen wird. 
Sie gibt die vom Fenster belegten Ressourcen frei, ohne die Anwendung zu beenden.

Wichtig: dispose() wird für GUI-Ressourcen verwendet, während close() für das Schließen von Streams oder Verbindungen zuständig ist.
Es ist eine grundlegende Entscheidung, ob du ein Fenster mit dispose() schließt oder es einfach unsichtbar machst (z.B. mit setVisible(false)).

dispose() gibt die vom Fenster belegten Ressourcen frei und entfernt es vollständig.
Wenn du das Fenster jedoch nur ausblenden möchtest, ohne die Ressourcen freizugeben, solltest du setVisible(false) verwenden. 
Wichtig ist, dass du nicht einfach das Fenster unsichtbar machst und dann ein neues öffnest, da dies zu unnötigen Ressourcenkosten führen kann.


Es ist eine grundlegende Entscheidung, ob du ein Fenster mit dispose() schließt oder es einfach unsichtbar machst (z.B. mit setVisible(false)).

dispose() gibt die vom Fenster belegten Ressourcen frei und entfernt es vollständig. Wenn du das Fenster jedoch nur ausblenden möchtest, ohne die Ressourcen freizugeben, solltest du setVisible(false) verwenden.
Wichtig ist, dass du nicht einfach das Fenster unsichtbar machst und dann ein neues öffnest, da dies zu unnötigen Ressourcenkosten führen kann.


Projektanforderungen:

    Spring Data mit JDBC (Derby):
        Nutze Spring Data JDBC zur Anbindung an eine Derby-Datenbank.
        Implementiere Repositories und verwalte Daten über JdbcTemplate.

    REST API:
        Entwickle eine RESTful API mit Spring Web und implementiere CRUD-Endpunkte mit @RestController.

    Pflichtenheft & Arbeitspakete:
        Erstelle ein Pflichtenheft mit klaren Arbeitspaketen: Datenbankkonfiguration, API-Entwicklung, Tests und Fehlerbehebung.

    Spring:
        Verwende Spring Boot für eine schnelle, wartbare Entwicklung und automatische Konfiguration.

    Troubleshooting:
        Nutze Logging und Testtools (z.B. Postman) zur Fehlerbehebung und zur Sicherstellung der Funktionsfähigkeit.

(Fasade Pattern benutzen) - add. Fabrikmuster (optional)


Ein Konstruktor dient der Initialisierung eines Objekts. Er kann Ausnahmen auslösen oder sie behandeln, wenn bei der Initialisierung Fehler auftreten.



Toolbox: Eine Sammlung nützlicher Funktionen, die jedoch aufgrund von Vererbung und komplexen Architekturen schwer zu pflegen sein kann. (Speichern und Laden)

Fabrikmethode: Eine Methode zur Erzeugung von Objekten. Sie stellt eine saubere Alternative zur Toolbox dar, indem sie die Objektinstanziierung kapselt und ermöglicht, 
verschiedene Typen von Objekten zu erzeugen, ohne dass der Aufrufer die genaue Klasse kennen muss. Sie kann auch zur Behandlung von Ausnahmen verwendet werden.


SOLID ist ein Akronym für fünf Prinzipien der objektorientierten Programmierung, die helfen, den Code wartbar, erweiterbar und verständlich zu halten:
    S - Single Responsibility Principle (SRP): Eine Klasse sollte nur eine einzige Aufgabe haben.
    O - Open/Closed Principle (OCP): Eine Klasse sollte offen für Erweiterungen, aber geschlossen für Änderungen sein.
    L - Liskov Substitution Principle (LSP): Objekte einer abgeleiteten Klasse sollten überall dort eingesetzt werden können, wo Objekte der Basisklasse verwendet werden.
    I - Interface Segregation Principle (ISP): Ein Client sollte nicht gezwungen sein, Methoden zu implementieren, die er nicht benötigt.
    D - Dependency Inversion Principle (DIP): Abhängigkeiten sollten von abstrakten Schnittstellen, nicht von konkreten Implementierungen abhängen.

KISS - Keep it small and stupid

Design Patterns - diese sollten oft frühzeitig in der Entwicklung berücksichtigt werden, besonders wenn du mit komplexeren Klassen oder Systemen arbeitest.
Wenn du eine neue Klasse erstellst, ist es sinnvoll, das passende Designmuster auszuwählen, um Struktur und Wartbarkeit zu gewährleisten.
Es geht darum, eine solide Grundlage zu schaffen, die später einfacher erweitert und gewartet werden kann.

Häufig angewandte Designmuster bei der Erstellung neuer Klassen:
    Factory Pattern:
        Wird verwendet, um Objekte zu erstellen, ohne die exakte Klasse zu kennen (Konstruktor alternative).
        Es bietet eine einheitliche Schnittstelle zur Instanziierung von Objekten.

    Singleton Pattern:
        Wird verwendet, wenn nur eine Instanz einer Klasse existieren soll 
        (z.B. für eine zentrale Konfiguration oder Log-Manager).

    Observer Pattern:
        Wird verwendet, wenn ein Objekt (der "Subject") Änderungen an seinen Zuständen an eine Liste von abhängigen Objekten (die "Observers") kommunizieren muss.

    Strategy Pattern:
        Wird verwendet, um ein Verhalten von einer Klasse zur Laufzeit auszutauschen. 
        Nützlich, wenn du eine Klasse hast, die mehrere Varianten von einem bestimmten Algorithmus implementieren muss.

    Decorator Pattern:
        Wird verwendet, um die Funktionalität eines Objekts zur Laufzeit zu erweitern, ohne die ursprüngliche Klasse zu verändern.

Modellierung in Java bezieht sich auf den Prozess, die realen Anforderungen und Konzepte in Softwareobjekte und -strukturen zu übersetzen.
Dabei wird die Geschäftslogik, der Ablauf und die Daten in einer abstrakten Form dargestellt, oft durch Klassen, Objekte und deren Beziehungen. 
Ziel der Modellierung ist es, eine klare und verständliche Repräsentation des Systems zu schaffen, die die Grundlage für die Implementierung bildet.

In Java erfolgt Modellierung typischerweise durch:
    Klassen und Objekte (Datenstruktur und Verhalten),
    Vererbung (Gemeinsamkeiten zwischen Klassen),
    Schnittstellen und abstrakte Klassen (Verträge und allgemeine Struktur),
    Beziehungen (Assoziationen, Aggregationen, Kompositionen).

Funktionale Anforderungen:
    Excel-Daten importieren und extrahieren.
    Daten validieren.
    Daten speichern.
    Fehler melden.

Nicht-funktionale Anforderungen:
    Import dauert max. 2 Sekunden.
    Fehler sicher abfangen.
    Einfache Benutzeroberfläche.
    Sicher und skalierbar.

Prozess zur Ableitung der Architektur aus nicht-funktionalen Anforderungen:
    Identifikation: Definiere nicht-funktionale Anforderungen (z.B. Performance, Sicherheit, Skalierbarkeit).
    Bewertung: Bestimme, wie diese Anforderungen die Architektur beeinflussen.
    Architekturentscheidungen: Wähle passende Architekturansätze (z.B. Caching, Microservices, Verschlüsselung).
    Muster auswählen: Nutze Architekturpattern (z.B. Schichtenarchitektur, Event-Driven).
    Evaluierung: Überprüfe regelmäßig, ob die Architektur die Anforderungen erfüllt und passe sie an.


Grales ist ein Open-Source-Framework zur Erstellung von modernen, robusten, skalierbaren und wartbaren Microservices und Webanwendungen.
Es basiert auf Grails, einem beliebten Framework für die Entwicklung von Webanwendungen in Groovy und Java und kombiniert die besten Konzepte von Spring und Grails.
Grales ermöglicht es Entwicklern, Microservices mit minimalem Aufwand zu erstellen, indem es Spring Boot und andere moderne Technologien nutzt.

#Vererbung mit Interfaces#

Basisklasse Vererbung:
In Java kann eine Klasse nur von einer einzigen Klasse erben, da Java einfache Vererbung unterstützt.
Das bedeutet, eine Klasse kann nur von einer anderen Klasse direkt erben, aber nicht von mehreren Klassen gleichzeitig.
Dadurch geht Vererbung über mehrere Klassen (wie bei Mehrfachvererbung in anderen Programmiersprachen) verloren.
Wenn du mehrere Funktionen von verschiedenen Klassen nutzen möchtest, kannst du Interfaces verwenden, da eine Klasse mehrere Interfaces implementieren kann.


Main-Klasse:
public class Main {
    public static void main(String[] args) {
        Hund hund = new Hund("Rex");
        hund.essen();
        hund.bellen();
    }
}

Basisklasse (Elternklasse):
public class Tier {
    String name;
    
    public Tier(String name) {
        this.name = name;
    }

    public void essen() {
        System.out.println(name + " isst.");
    }
}

Abgeleitete Klasse (Kindklasse):
public class Hund extends Tier {
    public Hund(String name) {
        super(name);
    }
    public void bellen() {
        System.out.println(name + " bellt.");
    }
}


--wichtig ist die Aussage welche man mit seinem code trifft--
Hint: defensives programmieren 


Ein Interface in Java definiert Methoden, die von einer Klasse implementiert werden müssen, ohne die Implementierung festzulegen. Es ermöglicht das Teilen von Funktionalitäten zwischen Klassen, ohne dass diese eine gemeinsame Basisklasse erben müssen.
Beispiele:

Serializable und Cloneable sind Marker-Interfaces, d.h. sie definieren keine Methoden. Sie kennzeichnen nur, dass Objekte der Klasse bestimmte Eigenschaften haben (z.B. serialisierbar oder klonbar).
Comparable ist ein Interface, das die Methode compareTo(T o) definiert, die implementiert werden muss, um Objekte zu vergleichen.

Marker-Interfaces: Keine Methoden (z.B. Serializable, Cloneable).
Normale Interfaces: Definieren Methoden, die implementiert werden müssen (z.B. Comparable).



#Polymorphismus#

In Java kann eine Basisklasse gemeinsamen Code (z.B. für Laden und Speichern von Daten) bereitstellen, den Unterklassen wiederverwenden. 
So wird Redundanz vermieden.

So wie Polymorphismus in Java ermöglicht es, dass Objekte unterschiedlicher Klassen über eine gemeinsame Schnittstelle oder 
Basisklasse aufgerufen werden können, wodurch die Flexibilität erhöht und der Code wiederverwendbar wird.

Eine abstrakte Methode in einer abstrakten Klasse ist wie eine leere Anleitung. 
Sie sagt, was gemacht werden muss, aber nicht, wie es geht. Jede Unterklasse muss diese Anleitung ausfüllen und erklären, wie es geht. 
Man kann keine Objekte von der abstrakten Klasse direkt erstellen, nur von den Unterklassen.


#Anononyme Innereklassen
Anonyme innere Klassen sind eine spezielle Art von inneren Klassen in Java, die keine explizite Klassendeklaration haben. 
Sie werden verwendet, wenn eine Klasse nur einmal benötigt wird, typischerweise bei der Erstellung von Objekten, 
die Instanzen eines Interfaces oder einer abstrakten Klasse sein müssen. Sie werden direkt im Code erstellt, 
ohne eine benannte Klasse zu definieren, was den Code kürzer und lesbarer macht.

#Interfaces
Ein Interface in Java ist eine Sammlung abstrakter Methoden, die von einer Klasse implementiert werden können. 
Ein Interface beschreibt, was eine Klasse tun sollte, aber nicht, wie sie es tun sollte. Interfaces ermöglichen es, 
dass verschiedene Klassen verschiedene Implementierungen für die gleichen Methoden bereitstellen können, wodurch Polymorphismus ermöglicht wird.
Eine Klasse, die ein Interface implementiert, muss alle Methoden des Interfaces implementieren (sofern sie nicht abstrakt ist). 
Ein Interface kann auch Konstanten enthalten, aber keine Instanzvariablen oder Methoden mit einer Implementierung.

#Kopplung
Kopplung in Java beschreibt, wie stark Klassen oder Module voneinander abhängen.
Starke Kopplung bedeutet, dass Klassen direkt voneinander abhängig sind. 
Änderungen in einer Klasse erfordern oft Anpassungen in anderen Klassen.
Schwache Kopplung bedeutet, dass Klassen so wenig wie möglich voneinander abhängen, oft durch Abstraktionen wie Interfaces oder Dependency Injection. Dadurch können Änderungen in einer Klasse ohne Auswirkungen auf andere Klassen vorgenommen werden.

Ziel: Eine niedrige Kopplung sorgt für flexibleren, wartbareren und erweiterbaren Code.



#SPRING easy Setup - für Jar Java21 - Maven
Lombok 
Spring Web 
Spring Data JPA 
Aapche Derby
pom.xml-Abhängigkeiten:

    Spring Web: Für REST-APIs (spring-boot-starter-web).
    Spring Data JPA: Für Datenbankzugriffe (spring-boot-starter-data-jpa).
    Lombok: Für weniger Boilerplate-Code (Getter, Setter, Konstruktoren).
    Apache Derby: In-Memory-Datenbank für einfache Persistenz (derby).

Hauptklasse:

    Spring Boot startet über @SpringBootApplication Annotation.

Datenbank-Konfiguration:

    In application.properties die JDBC-Verbindung zu Apache Derby konfigurieren.

Entität und Repository:

    Erstelle eine Entität (@Entity) und ein Repository (JpaRepository) für Datenzugriffe.

Controller:

    Erstelle einen einfachen REST-Controller mit Endpunkten (@GetMapping, @PostMapping).

Build & Run:

    Baue das Projekt mit mvn clean install.
    Starte das Projekt mit mvn spring-boot:run